import { app, Tray, Menu, globalShortcut, clipboard, nativeImage, BrowserWindow, screen, ipcMain } from 'electron';
import fs from 'fs';
import path from 'path';
import { callOpenAIForQuickEdit, callWhisperApi, callTextToSpeechApi } from './openai-api';
import { config } from './config';
import { AudioRecorder } from './audio-recorder';
import { ClipboardHistory } from './clipboard-history';
import { AudioPlayer } from './audio-player';
import { pythonSpellCaster } from './python-spells';

// This allows TypeScript to pick up the magic constants that are auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code.
// We don't have a window anymore, but we'll keep these for potential future use.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_WEBPACK_ENTRY: string;
declare const SETTINGS_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_WEBPACK_ENTRY: string;
declare const SPELL_BOOK_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let tray: Tray | null = null;
let recorder: AudioRecorder | null = null;
let visualizerWindow: null = null;
let pastilleWindow: BrowserWindow | null = null;
let settingsWindow: BrowserWindow | null = null;
let spellBookWindow: BrowserWindow | null = null;
let clipboardHistory: ClipboardHistory | null = null;
let audioPlayer: AudioPlayer | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const handleClipboardNext = () => {
  console.log('âž¡ï¸ handleClipboardNext triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cycleNext();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('ðŸ“‹ Next clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleClipboardPrevious = () => {
  console.log('â¬…ï¸ handleClipboardPrevious triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cyclePrevious();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('ðŸ“‹ Previous clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleShowClipboard = () => {
  console.log('ðŸ‘ï¸ handleShowClipboard triggered!');
  showPastille(); // Show current clipboard state
};

const showPastille = () => {
  if (!pastilleWindow || !clipboardHistory) return;
  
  const currentEntry = clipboardHistory.getCurrentEntry();
  const currentIndex = clipboardHistory.getCurrentIndex();
  const totalCount = clipboardHistory.getHistoryLength();
  
  // Get fresh cursor position each time
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  
  // Calculate position with bounds checking
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 60;
  
  // Keep pastille on screen
  if (x + 520 > screenWidth) {
    x = cursorPosition.x - 540; // Show to the left of cursor
  }
  if (y < 0) {
    y = cursorPosition.y + 20; // Show below cursor
  }
  
  console.log('ðŸ–±ï¸ Cursor position:', cursorPosition, '-> Pastille position:', { x, y });
  
  pastilleWindow.setPosition(x, y);
  
  pastilleWindow.webContents.send('clipboard-updated', {
    entry: currentEntry,
    currentIndex: currentIndex,
    totalCount: totalCount
  });
  
  pastilleWindow.webContents.send('show-pastille');
  pastilleWindow.show(); // Make sure the window is shown
  console.log('ðŸ‘ï¸ Pastille window shown at cursor position');
};

// Utility to position pill near current cursor
const positionPillNearCursor = () => {
  if (!pastilleWindow) return;
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 80;
  if (x + 520 > screenWidth) x = cursorPosition.x - 540;
  if (y < 0) y = cursorPosition.y + 20;
  pastilleWindow.setPosition(x, y);
};

const handleQuickEdit = async () => {
  console.log('ðŸš€ handleQuickEdit triggered!');
  if (!config.OPENAI_API_KEY) {
    console.log('âŒ No OpenAI API key found');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Configuration Error: OpenAI API key is not set.');
    pastilleWindow?.show();
    return;
  }
  const text = clipboard.readText();
  console.log('ðŸ“‹ Clipboard text:', text ? `"${text}"` : 'EMPTY');
  if (!text) {
    console.log('âŒ No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit â€“ No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  console.log('â³ Starting OpenAI processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Processing');
  pastilleWindow?.show();

  const response = await callOpenAIForQuickEdit(text);
  console.log('ðŸ“ OpenAI response:', response ? `"${response}"` : 'NULL');

  if (response) {
    clipboard.writeText(response);
    console.log('âœ… Text processed and copied to clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', response);
    pastilleWindow?.show();
  } else {
    console.log('âŒ Failed to process text');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Quick Edit â€“ Failed to process text!');
    pastilleWindow?.show();
  }
};

const processRecording = async (filePath: string) => {
  try {
    console.log(`ðŸ”„ Processing recording from ${filePath}`);
    const transcript = await callWhisperApi(filePath);
    console.log('ðŸ“ Whisper transcript:', transcript ? `"${transcript}"` : 'NULL');

    if (transcript) {
      // Save transcript to a file next to the recording
      const transcriptPath = filePath.replace('.wav', '.txt');
      fs.writeFileSync(transcriptPath, transcript);
      
      // Copy to clipboard
      clipboard.writeText(transcript);
      
      console.log(`ðŸ’¾ Transcript saved to ${transcriptPath} and copied to clipboard`);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', transcript);
      pastilleWindow?.show();
    } else {
      console.log('âŒ Failed to transcribe audio');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Failed to transcribe audio.');
      pastilleWindow?.show();
    }
  } catch (e) {
    console.error('âŒ Error processing recording:', e);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `Error â€“ Failed to process recording: ${e.message}`);
    pastilleWindow?.show();
  } finally {
    // Clean up the recording file
    // fs.unlink(filePath, (err) => {
    //   if (err) console.error(`Failed to delete audio file: ${filePath}`, err);
    //   else console.log(`Deleted audio file: ${filePath}`);
    // });
  }
};

const handleVoiceRecord = () => {
  console.log('ðŸŽ¤ handleVoiceRecord triggered!');
  if (recorder && recorder.isRecording) {
    console.log('ðŸ›‘ Stopping recording...');
    recorder.stop();
    // Visualizer merged into pastille â€“ no separate window needed
    // stop showing waveform; pastille will switch to processing
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-processing', 'Processing');
    pastilleWindow?.show();
  } else {
    console.log('ðŸŽ™ï¸ Starting recording...');
    recorder = new AudioRecorder();
    recorder.start();

    // Tell pastille to enter recording mode with waveform
    positionPillNearCursor();
    pastilleWindow?.webContents.send('start-recording', 'Recording... Press Ctrl+Alt+W to stop.');
    pastilleWindow?.show();

    recorder.on('audio-data', (data: Buffer) => {
      pastilleWindow?.webContents.send('audio-data', data);
    });

    recorder.on('finished', (filePath: string) => {
      console.log('âœ… Recording finished, file:', filePath);
      processRecording(filePath);
      recorder = null; // Reset recorder
    });

    recorder.on('error', (error: any) => {
      console.log('âŒ Recording error:', error);
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', `Recording Error â€“ ${error.message}`);
      pastilleWindow?.show();
      recorder = null; // Reset recorder
    });
  }
};

const handleTextToSpeech = async () => {
  console.log('ðŸ”Š handleTextToSpeech triggered!');
  if (!config.OPENAI_API_KEY) {
    console.log('âŒ No OpenAI API key found');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Configuration Error: OpenAI API key is not set.');
    pastilleWindow?.show();
    return;
  }

  const text = clipboard.readText();
  console.log('ðŸ“‹ Clipboard text for TTS:', text ? `"${text.substring(0, 100)}..."` : 'EMPTY');
  
  if (!text) {
    console.log('âŒ No text in clipboard');
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Text-to-Speech â€“ No text in clipboard!');
    pastilleWindow?.show();
    return;
  }

  // Stop any currently playing audio
  if (audioPlayer && audioPlayer.playing) {
    console.log('ðŸ›‘ Stopping current audio playback');
    audioPlayer.stop();
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', 'Audio playback stopped.');
    pastilleWindow?.show();
    return;
  }

  console.log('â³ Starting TTS processing...');
  positionPillNearCursor();
  pastilleWindow?.webContents.send('show-processing', 'Generating speech');
  pastilleWindow?.show();

  try {
    const audioFilePath = await callTextToSpeechApi(text, config.TTS_VOICE);
    console.log('ðŸŽµ TTS response:', audioFilePath ? `"${audioFilePath}"` : 'NULL');

    if (audioFilePath) {
      console.log('ðŸ”Š Starting audio playback...');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'ðŸ”Š Playing audio... (Ctrl+Alt+E to stop)');
      pastilleWindow?.show();

      // Initialize audio player if needed
      if (!audioPlayer) {
        audioPlayer = new AudioPlayer();
        
        audioPlayer.on('finished', () => {
          console.log('âœ… Audio playback finished');
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', 'Audio playback completed.');
          pastilleWindow?.show();
          
          // Clean up the temporary file
          setTimeout(() => {
            if (fs.existsSync(audioFilePath)) {
              fs.unlinkSync(audioFilePath);
              console.log('ðŸ—‘ï¸ Cleaned up temporary audio file');
            }
          }, 1000);
        });

        audioPlayer.on('error', (error) => {
          console.error('âŒ Audio playback error:', error);
          positionPillNearCursor();
          pastilleWindow?.webContents.send('show-message', `Audio Error â€“ ${error.message}`);
          pastilleWindow?.show();
        });

        audioPlayer.on('stopped', () => {
          console.log('ðŸ›‘ Audio playback stopped');
        });
      }

      await audioPlayer.play(audioFilePath);
    } else {
      console.log('âŒ Failed to generate speech');
      positionPillNearCursor();
      pastilleWindow?.webContents.send('show-message', 'Text-to-Speech â€“ Failed to generate audio!');
      pastilleWindow?.show();
    }
  } catch (error) {
    console.error('âŒ TTS error:', error);
    positionPillNearCursor();
    pastilleWindow?.webContents.send('show-message', `TTS Error â€“ ${error.message}`);
    pastilleWindow?.show();
  }
};

app.on('ready', async () => {
  console.log('ðŸš€ App ready event triggered');
  
  // Initialize clipboard history
  console.log('ðŸ“‹ Initializing clipboard history...');
  clipboardHistory = new ClipboardHistory(50);
  
  clipboardHistory.on('history-updated', (entry) => {
    console.log('ðŸ“‹ Clipboard history updated:', entry?.text?.substring(0, 50) + '...');
  });
  
  clipboardHistory.on('current-changed', (entry) => {
    console.log('ðŸ“‹ Current clipboard entry changed:', entry?.text?.substring(0, 50) + '...');
  });
  
  console.log('âœ… Clipboard history initialized');
  
  // Initialize Python Spell Caster
  console.log('ðŸ§™â€â™‚ï¸ Initializing Python Spell Caster...');
  try {
    await pythonSpellCaster.initialize();
    console.log('âœ… Python Spell Caster initialized');
  } catch (error) {
    console.error('âŒ Failed to initialize Python Spell Caster:', error);
  }
  
  // Create the visualizer window
  console.log('ðŸªŸ Creating visualizer window...');
  // Visualizer merged into pastille â€“ no separate window needed
  // let visualizerWindow = new BrowserWindow({
  //   width: 200,
  //   height: 60,
  //   frame: false,
  //   transparent: true,
  //   alwaysOnTop: true,
  //   show: false,
  //   resizable: false,
  //   webPreferences: {
  //     nodeIntegration: true,
  //     contextIsolation: false, // Needed for ipcRenderer in visualizer.ts without a preload script
  //   },
  // });

  // visualizerWindow.loadURL(VISUALIZER_WINDOW_WEBPACK_ENTRY);
  // visualizerWindow.setIgnoreMouseEvents(true); // Make the window click-through
  // console.log('âœ… Visualizer window created');
  
  // Create the pastille window
  console.log('ðŸªŸ Creating pastille window...');
  pastilleWindow = new BrowserWindow({
    width: 500,
    height: 70,
    frame: false,
    transparent: true,
    alwaysOnTop: false,
    show: false,
    resizable: true,
    skipTaskbar: true,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false, // Needed for ipcRenderer in pastille.ts without a preload script
    },
  });

  pastilleWindow.loadURL(PASTILLE_WINDOW_WEBPACK_ENTRY);
  // Allow mouse events so user can drag the pill
  pastilleWindow.setIgnoreMouseEvents(false);
  
  // Initialize pastille with current clipboard content once it's ready
  pastilleWindow.webContents.once('did-finish-load', () => {
    console.log('ðŸŽ¯ Pastille window loaded, initializing with current clipboard');
    setTimeout(() => {
      const currentEntry = clipboardHistory?.getCurrentEntry();
      const currentIndex = clipboardHistory?.getCurrentIndex() ?? -1;
      const totalCount = clipboardHistory?.getHistoryLength() ?? 0;
      
      pastilleWindow?.webContents.send('clipboard-updated', {
        entry: currentEntry,
        currentIndex: currentIndex,
        totalCount: totalCount
      });
    }, 100);
  });
  
  console.log('âœ… Pastille window created');

  // We don't want a window, just a tray icon.
  // Create a native image from a data URL for the tray icon.
  // This is a simple 16x16 transparent PNG.
  console.log('ðŸ–¼ï¸ Creating tray icon...');
  const image = nativeImage.createFromDataURL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAEklEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  );
  tray = new Tray(image);
  
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Exit', type: 'normal', click: () => app.quit() },
  ]);

  tray.setToolTip('MetaKeyAI');
  tray.setContextMenu(contextMenu);
  console.log('âœ… Tray created');
  
  showPillNotification('MetaKeyAI running in background\nCtrl+Alt+Q: Quick edit\nCtrl+Alt+W: Voice record\nCtrl+Alt+E: Text-to-speech\nCtrl+Alt+C: Show clipboard\nCtrl+Alt+â†/â†’: Clipboard history');

  if (!config.OPENAI_API_KEY) {
    console.log('âš ï¸ No OpenAI API key found in config');
    showPillNotification('Configuration Warning â€“ OpenAI API key not set. Voice and edit features will not work.');
  } else {
    console.log('âœ… OpenAI API key found in config');
  }

  // Register global shortcuts
  console.log('âŒ¨ï¸ Registering global shortcuts...');
  const quickEditResult = globalShortcut.register('CommandOrControl+Alt+Q', handleQuickEdit);
  const voiceRecordResult = globalShortcut.register('CommandOrControl+Alt+W', handleVoiceRecord);
  const clipboardNextResult = globalShortcut.register('CommandOrControl+Alt+Right', handleClipboardNext);
  const clipboardPrevResult = globalShortcut.register('CommandOrControl+Alt+Left', handleClipboardPrevious);
  const showClipboardResult = globalShortcut.register('CommandOrControl+Alt+C', handleShowClipboard);
  const textToSpeechResult = globalShortcut.register('CommandOrControl+Alt+E', handleTextToSpeech);
  
  console.log('âŒ¨ï¸ Ctrl+Alt+Q registered:', quickEditResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+W registered:', voiceRecordResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+Right registered:', clipboardNextResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+Left registered:', clipboardPrevResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+C registered:', showClipboardResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+E registered:', textToSpeechResult);
  
  if (!quickEditResult || !voiceRecordResult || !clipboardNextResult || !clipboardPrevResult || !showClipboardResult || !textToSpeechResult) {
    console.log('âŒ Failed to register some global shortcuts');
  } else {
    console.log('âœ… All global shortcuts registered successfully');
  }

  // Add IPC listener for update-clipboard
  ipcMain.on('update-clipboard', (event, text) => {
    console.log('ðŸ“‹ Received update-clipboard event:', text);
    clipboard.writeText(text);
    showPastille();
  });

  // Add IPC listener for update-clipboard-draft (real-time editing)
  ipcMain.on('update-clipboard-draft', (event, text) => {
    console.log('ðŸ“ Received update-clipboard-draft event:', text.substring(0, 50) + '...');
    clipboard.writeText(text);
    // Don't show pastille for draft updates to avoid interrupting editing
  });

  // Add IPC listener for expand-pastille
  ipcMain.on('expand-pastille', () => {
    if (pastilleWindow) {
      const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
      const targetWidth = Math.round(screenWidth * 0.7);
      const targetHeight = Math.round(screenHeight * 0.6);
      pastilleWindow.setAlwaysOnTop(true);
      pastilleWindow.setSize(targetWidth, targetHeight, true);
      pastilleWindow.center();
    }
  });

  // Add IPC listener for collapse-pastille
  ipcMain.on('collapse-pastille', () => {
    if (pastilleWindow) {
      pastilleWindow.setSize(500, 70, true);
      pastilleWindow.setAlwaysOnTop(false);
    }
  });

  // Add IPC listener for clipboard navigation from control bar
  ipcMain.on('clipboard-navigate', (event, direction) => {
    console.log('ðŸ”„ Received clipboard-navigate event:', direction);
    if (direction === 'next') {
      handleClipboardNext();
    } else if (direction === 'previous') {
      handleClipboardPrevious();
    }
  });

  // Add IPC listener for opening settings
  ipcMain.on('open-settings', () => {
    console.log('âš™ï¸ Opening settings window...');
    openSettingsWindow();
  });

  // Add IPC listener for opening spell book
  ipcMain.on('open-spell-book', () => {
    console.log('ðŸ§™â€â™‚ï¸ Opening spell book window...');
    openSpellBookWindow();
  });

  // Add IPC listeners for settings management
  ipcMain.on('load-settings', (event) => {
    console.log('ðŸ“‹ Loading settings for dashboard...');
    const settings = {
      OPENAI_API_KEY: config.OPENAI_API_KEY || '',
      QUICK_EDIT_MODEL_OPENAI: config.QUICK_EDIT_MODEL_OPENAI,
      WHISPER_MODEL: config.WHISPER_MODEL,
      TTS_VOICE: config.TTS_VOICE
    };
    event.reply('settings-loaded', settings);
  });

  ipcMain.on('save-settings', (event, newSettings) => {
    console.log('ðŸ’¾ Saving settings from dashboard...');
    try {
      // Update config object (note: this only updates runtime, not persistent storage)
      config.OPENAI_API_KEY = newSettings.OPENAI_API_KEY;
      config.QUICK_EDIT_MODEL_OPENAI = newSettings.QUICK_EDIT_MODEL_OPENAI;
      config.WHISPER_MODEL = newSettings.WHISPER_MODEL;
      config.TTS_VOICE = newSettings.TTS_VOICE;
      
      console.log('âœ… Settings updated successfully');
      event.reply('settings-saved', true, 'Settings saved successfully!');
    } catch (error) {
      console.error('âŒ Error saving settings:', error);
      event.reply('settings-saved', false, 'Failed to save settings: ' + error.message);
    }
  });

  ipcMain.on('validate-api-key', async (event, apiKey) => {
    console.log('ðŸ” Validating API key...');
    try {
      // Simple validation - try to make a basic API call with timeout
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000);
      
      const response = await fetch('https://api.openai.com/v1/models', {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
        },
        signal: controller.signal
      });
      
      clearTimeout(timeoutId);
      const isValid = response.ok;
      console.log('ðŸ”‘ API key validation result:', isValid);
      event.reply('api-key-validated', isValid);
    } catch (error) {
      console.log('âŒ API key validation failed:', error.message);
      event.reply('api-key-validated', false);
    }
  });

  ipcMain.on('test-voice', async (event, { voice, text }) => {
    console.log('ðŸ”Š Testing voice from settings:', voice);
    try {
      const audioFilePath = await callTextToSpeechApi(text, voice);
      if (audioFilePath && audioPlayer) {
        await audioPlayer.play(audioFilePath);
      }
    } catch (error) {
      console.error('âŒ Voice test error:', error);
    }
  });
});

const openSettingsWindow = () => {
  // If settings window already exists, focus it
  if (settingsWindow) {
    settingsWindow.focus();
    return;
  }

  console.log('ðŸªŸ Creating settings window...');
  settingsWindow = new BrowserWindow({
    width: 700,
    height: 900,
    minWidth: 600,
    minHeight: 700,
    title: 'MetaKeyAI Settings',
    icon: null, // You can add an icon here
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  settingsWindow.loadURL(SETTINGS_WINDOW_WEBPACK_ENTRY);

  settingsWindow.once('ready-to-show', () => {
    settingsWindow?.show();
    console.log('âœ… Settings window ready and shown');
  });

  settingsWindow.on('closed', () => {
    settingsWindow = null;
    console.log('ðŸšª Settings window closed');
  });
};

const openSpellBookWindow = () => {
  // If spell book window already exists, focus it
  if (spellBookWindow) {
    spellBookWindow.focus();
    return;
  }

  console.log('ðŸªŸ Creating spell book window...');
  spellBookWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    title: 'Python Spell Book - MetaKeyAI',
    icon: null,
    show: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false,
    },
  });

  // Load the spell book HTML file
  spellBookWindow.loadURL(SPELL_BOOK_WINDOW_WEBPACK_ENTRY);

  spellBookWindow.once('ready-to-show', () => {
    spellBookWindow?.show();
    console.log('âœ… Spell book window ready and shown');
  });

  spellBookWindow.on('closed', () => {
    spellBookWindow = null;
    console.log('ðŸšª Spell book window closed');
  });
};

// Since there are no windows, we don't need to handle 'window-all-closed'
// The app will continue running in the background.

app.on('will-quit', () => {
  // Unregister all shortcuts.
  globalShortcut.unregisterAll();
  
  // Cleanup clipboard history
  if (clipboardHistory) {
    clipboardHistory.destroy();
    clipboardHistory = null;
  }
  
  // Cleanup audio player
  if (audioPlayer) {
    audioPlayer.stop();
    audioPlayer = null;
  }
  
  // Cleanup Python Spell Caster
  pythonSpellCaster.cleanup();
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.

/**
 * Shows a pill-style notification instead of the system notification.
 * Positions it near the bottom-right of the primary display.
 */
const showPillNotification = (message: string) => {
  if (!pastilleWindow) {
    console.warn('Pastille window not ready, cannot show pill notification');
    return;
  }

  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;

  const x = screenWidth - 500; // leave some margin
  const y = screenHeight - 100;

  pastilleWindow.setPosition(x, y);
  pastilleWindow.webContents.send('show-message', message);
  pastilleWindow.show();
};
