import { app, Tray, Menu, globalShortcut, clipboard, Notification, nativeImage, BrowserWindow, screen } from 'electron';
import path from 'path';
import fs from 'fs';
import os from 'os';
import { callOpenAIForQuickEdit, callWhisperApi } from './openai-api';
import { config } from './config';
import { AudioRecorder } from './audio-recorder';
import { ClipboardHistory } from './clipboard-history';

// This allows TypeScript to pick up the magic constants that are auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code.
// We don't have a window anymore, but we'll keep these for potential future use.
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_WEBPACK_ENTRY: string;
declare const VISUALIZER_WINDOW_PRELOAD_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_WEBPACK_ENTRY: string;
declare const PASTILLE_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

let tray: Tray | null = null;
let recorder: AudioRecorder | null = null;
let visualizerWindow: BrowserWindow | null = null;
let pastilleWindow: BrowserWindow | null = null;
let clipboardHistory: ClipboardHistory | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

const handleClipboardNext = () => {
  console.log('âž¡ï¸ handleClipboardNext triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cycleNext();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('ðŸ“‹ Next clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleClipboardPrevious = () => {
  console.log('â¬…ï¸ handleClipboardPrevious triggered!');
  if (!clipboardHistory) return;
  
  const entry = clipboardHistory.cyclePrevious();
  showPastille(); // Always show pastille to see current state
  if (entry) {
    console.log('ðŸ“‹ Previous clipboard entry:', entry.text.substring(0, 50) + '...');
  }
};

const handleShowClipboard = () => {
  console.log('ðŸ‘ï¸ handleShowClipboard triggered!');
  showPastille(); // Show current clipboard state
};

const showPastille = () => {
  if (!pastilleWindow || !clipboardHistory) return;
  
  const currentEntry = clipboardHistory.getCurrentEntry();
  const currentIndex = clipboardHistory.getCurrentIndex();
  const totalCount = clipboardHistory.getHistoryLength();
  
  // Get fresh cursor position each time
  const cursorPosition = screen.getCursorScreenPoint();
  const { width: screenWidth, height: screenHeight } = screen.getPrimaryDisplay().workAreaSize;
  
  // Calculate position with bounds checking
  let x = cursorPosition.x + 20;
  let y = cursorPosition.y - 60;
  
  // Keep pastille on screen
  if (x + 350 > screenWidth) {
    x = cursorPosition.x - 370; // Show to the left of cursor
  }
  if (y < 0) {
    y = cursorPosition.y + 20; // Show below cursor
  }
  
  console.log('ðŸ–±ï¸ Cursor position:', cursorPosition, '-> Pastille position:', { x, y });
  
  pastilleWindow.setPosition(x, y);
  
  pastilleWindow.webContents.send('clipboard-updated', {
    entry: currentEntry,
    currentIndex: currentIndex,
    totalCount: totalCount
  });
  
  pastilleWindow.webContents.send('show-pastille');
  pastilleWindow.show(); // Make sure the window is shown
  console.log('ðŸ‘ï¸ Pastille window shown at cursor position');
};

const handleQuickEdit = async () => {
  console.log('ðŸš€ handleQuickEdit triggered!');
  if (!config.OPENAI_API_KEY) {
    console.log('âŒ No OpenAI API key found');
    new Notification({ title: 'Configuration Error', body: 'OpenAI API key is not set.' }).show();
    return;
  }
  const text = clipboard.readText();
  console.log('ðŸ“‹ Clipboard text:', text ? `"${text}"` : 'EMPTY');
  if (!text) {
    console.log('âŒ No text in clipboard');
    new Notification({ title: 'Quick Edit', body: 'No text in clipboard!' }).show();
    return;
  }

  console.log('â³ Starting OpenAI processing...');
  new Notification({ title: 'Quick Edit', body: 'Processing...' }).show();

  const response = await callOpenAIForQuickEdit(text);
  console.log('ðŸ“ OpenAI response:', response ? `"${response}"` : 'NULL');

  if (response) {
    clipboard.writeText(response);
    console.log('âœ… Text processed and copied to clipboard');
    new Notification({ title: 'Quick Edit', body: 'Text processed! Ready to paste.' }).show();
  } else {
    console.log('âŒ Failed to process text');
    new Notification({ title: 'Quick Edit', body: 'Failed to process text!' }).show();
  }
};

const processRecording = async (filePath: string) => {
  try {
    console.log(`ðŸ”„ Processing recording from ${filePath}`);
    const transcript = await callWhisperApi(filePath);
    console.log('ðŸ“ Whisper transcript:', transcript ? `"${transcript}"` : 'NULL');

    if (transcript) {
      // Save transcript to a file next to the recording
      const transcriptPath = filePath.replace('.wav', '.txt');
      fs.writeFileSync(transcriptPath, transcript);
      
      // Copy to clipboard
      clipboard.writeText(transcript);
      
      console.log(`ðŸ’¾ Transcript saved to ${transcriptPath} and copied to clipboard`);
      new Notification({ title: 'Voice Record', body: 'Transcript saved and copied to clipboard!' }).show();
    } else {
      console.log('âŒ Failed to transcribe audio');
      new Notification({ title: 'Voice Record', body: 'Failed to transcribe audio.' }).show();
    }
  } catch (e) {
    console.error('âŒ Error processing recording:', e);
    new Notification({ title: 'Error', body: `Failed to process recording: ${e.message}` }).show();
  } finally {
    // Clean up the recording file
    // fs.unlink(filePath, (err) => {
    //   if (err) console.error(`Failed to delete audio file: ${filePath}`, err);
    //   else console.log(`Deleted audio file: ${filePath}`);
    // });
  }
};

const handleVoiceRecord = () => {
  console.log('ðŸŽ¤ handleVoiceRecord triggered!');
  if (recorder && recorder.isRecording) {
    console.log('ðŸ›‘ Stopping recording...');
    recorder.stop();
    visualizerWindow?.hide();
    new Notification({ title: 'Voice Record', body: 'Recording stopped. Processing...' }).show();
  } else {
    console.log('ðŸŽ™ï¸ Starting recording...');
    recorder = new AudioRecorder();
    recorder.start();

    // Show and position the visualizer window
    const cursorPosition = screen.getCursorScreenPoint();
    console.log('ðŸ–±ï¸ Cursor position:', cursorPosition);
    visualizerWindow?.setPosition(cursorPosition.x + 20, cursorPosition.y + 20);
    visualizerWindow?.show();
    console.log('ðŸ‘ï¸ Visualizer window shown');

    recorder.on('audio-data', (data: Buffer) => {
      // console.log('ðŸ”Š Audio data received:', data.length, 'bytes'); // Too verbose
      visualizerWindow?.webContents.send('audio-data', data);
    });

    recorder.on('finished', (filePath: string) => {
      console.log('âœ… Recording finished, file:', filePath);
      processRecording(filePath);
      recorder = null; // Reset recorder
    });

    recorder.on('error', (error: any) => {
      console.log('âŒ Recording error:', error);
      new Notification({ title: 'Recording Error', body: `An error occurred: ${error.message}`}).show();
      recorder = null; // Reset recorder
    });

    new Notification({ title: 'Voice Record', body: 'Recording... Press Ctrl+Alt+W to stop.' }).show();
  }
};

app.on('ready', () => {
  console.log('ðŸš€ App ready event triggered');
  
  // Initialize clipboard history
  console.log('ðŸ“‹ Initializing clipboard history...');
  clipboardHistory = new ClipboardHistory(50);
  
  clipboardHistory.on('history-updated', (entry) => {
    console.log('ðŸ“‹ Clipboard history updated:', entry?.text?.substring(0, 50) + '...');
  });
  
  clipboardHistory.on('current-changed', (entry) => {
    console.log('ðŸ“‹ Current clipboard entry changed:', entry?.text?.substring(0, 50) + '...');
  });
  
  console.log('âœ… Clipboard history initialized');
  
  // Create the visualizer window
  console.log('ðŸªŸ Creating visualizer window...');
  visualizerWindow = new BrowserWindow({
    width: 200,
    height: 60,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    show: false,
    resizable: false,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false, // Needed for ipcRenderer in visualizer.ts without a preload script
    },
  });

  visualizerWindow.loadURL(VISUALIZER_WINDOW_WEBPACK_ENTRY);
  visualizerWindow.setIgnoreMouseEvents(true); // Make the window click-through
  console.log('âœ… Visualizer window created');
  
  // Create the pastille window
  console.log('ðŸªŸ Creating pastille window...');
  pastilleWindow = new BrowserWindow({
    width: 350,
    height: 50,
    frame: false,
    transparent: true,
    alwaysOnTop: true,
    show: false,
    resizable: false,
    skipTaskbar: true,
    webPreferences: {
      nodeIntegration: true,
      contextIsolation: false, // Needed for ipcRenderer in pastille.ts without a preload script
    },
  });

  pastilleWindow.loadURL(PASTILLE_WINDOW_WEBPACK_ENTRY);
  pastilleWindow.setIgnoreMouseEvents(true); // Make the window click-through
  
  // Initialize pastille with current clipboard content once it's ready
  pastilleWindow.webContents.once('did-finish-load', () => {
    console.log('ðŸŽ¯ Pastille window loaded, initializing with current clipboard');
    setTimeout(() => {
      const currentEntry = clipboardHistory?.getCurrentEntry();
      const currentIndex = clipboardHistory?.getCurrentIndex() ?? -1;
      const totalCount = clipboardHistory?.getHistoryLength() ?? 0;
      
      pastilleWindow?.webContents.send('clipboard-updated', {
        entry: currentEntry,
        currentIndex: currentIndex,
        totalCount: totalCount
      });
    }, 100);
  });
  
  console.log('âœ… Pastille window created');

  // We don't want a window, just a tray icon.
  // Create a native image from a data URL for the tray icon.
  // This is a simple 16x16 transparent PNG.
  console.log('ðŸ–¼ï¸ Creating tray icon...');
  const image = nativeImage.createFromDataURL(
    'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAQAAAC1+jfqAAAAEklEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='
  );
  tray = new Tray(image);
  
  const contextMenu = Menu.buildFromTemplate([
    { label: 'Exit', type: 'normal', click: () => app.quit() },
  ]);

  tray.setToolTip('MetaKeyAI');
  tray.setContextMenu(contextMenu);
  console.log('âœ… Tray created');
  
  new Notification({
      title: 'MetaKeyAI',
      body: 'Running in background\nCtrl+Alt+Q for quick edit\nCtrl+Alt+W for voice record\nCtrl+Alt+C to show clipboard\nCtrl+Alt+Right/Left for clipboard history'
  }).show();

  if (!config.OPENAI_API_KEY) {
    console.log('âš ï¸ No OpenAI API key found in config');
    new Notification({ title: 'Configuration Warning', body: 'OpenAI API key not set. Voice and edit features will not work.' }).show();
  } else {
    console.log('âœ… OpenAI API key found in config');
  }

  // Register global shortcuts
  console.log('âŒ¨ï¸ Registering global shortcuts...');
  const quickEditResult = globalShortcut.register('CommandOrControl+Alt+Q', handleQuickEdit);
  const voiceRecordResult = globalShortcut.register('CommandOrControl+Alt+W', handleVoiceRecord);
  const clipboardNextResult = globalShortcut.register('CommandOrControl+Alt+Right', handleClipboardNext);
  const clipboardPrevResult = globalShortcut.register('CommandOrControl+Alt+Left', handleClipboardPrevious);
  const showClipboardResult = globalShortcut.register('CommandOrControl+Alt+C', handleShowClipboard);
  
  console.log('âŒ¨ï¸ Ctrl+Alt+Q registered:', quickEditResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+W registered:', voiceRecordResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+Right registered:', clipboardNextResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+Left registered:', clipboardPrevResult);
  console.log('âŒ¨ï¸ Ctrl+Alt+C registered:', showClipboardResult);
  
  if (!quickEditResult || !voiceRecordResult || !clipboardNextResult || !clipboardPrevResult || !showClipboardResult) {
    console.log('âŒ Failed to register some global shortcuts');
  } else {
    console.log('âœ… All global shortcuts registered successfully');
  }
});

// Since there are no windows, we don't need to handle 'window-all-closed'
// The app will continue running in the background.

app.on('will-quit', () => {
  // Unregister all shortcuts.
  globalShortcut.unregisterAll();
  
  // Cleanup clipboard history
  if (clipboardHistory) {
    clipboardHistory.destroy();
    clipboardHistory = null;
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
